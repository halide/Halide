#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <assert.h>

int sdiv(int a, int b) {
  return (a - ((a % b) + b) % b) / b;
}

bool u_method_0(int den, int sh_post, int bits) {
    int max = (1 << bits) - 1;
    for (int num = 0; num <= max; num++) {	
	uint64_t result = num;
	result >>= sh_post;
	if (sdiv(num, den) != result) return false;
    }
    return true;
}

bool u_method_1(int den, int mul, int sh_post, int bits) {
    int max = (1 << bits) - 1;
    for (int num = 0; num <= max; num++) {
	uint64_t result = num;
	result *= mul;
	result >>= bits;
	if (result > max) return false;
	result >>= sh_post;
	if (sdiv(num, den) != result) return false;
    }
    return true;
}

bool u_method_2(int den, int mul, int sh_post, int bits) {
    int max = (1 << bits) - 1;
    for (int num = 0; num <= max; num++) {
	uint64_t result = num;
	result *= mul;
	result >>= bits;
	if (result > max) return false;
	result += (num - result)>>1;
	if (result > max) return false;
	result >>= sh_post;
	if (sdiv(num, den) != result) return false;
    }
    return true;    
}

//These are not useful when you want signed division to always round to negative infinity 
bool s_method_0(int den, int sh_post, int bits) {
    int min = -(1 << (bits-1)), max = (1 << (bits-1))-1;
    for (int num = min; num <= max; num++) {
        int64_t result = num;
	result >>= sh_post;
	if (sdiv(num, den) != result) return false;
    }
    return true;
}

/*
bool s_method_1(int den, int mul, int sh_post, int bits) {
    int min = -(1 << (bits-1)), max = (1 << (bits-1))-1;
    for (int num = min; num <= max; num++) {    
	int64_t result = num;
        if (num < -1) result++;
	result *= mul;
	result >>= bits;
	if (result > max || result < min) return false;
        //if (num < 0) result += num;
	if (result > max || result < min) return false;
	result >>= sh_post;
	if (sdiv(num, den) != result) return false;
    }
    return true;    
}
*/

bool s_method_1(int den, int mul, int sh_post, int bits) {
    int min = -(1 << (bits-1)), max = (1 << (bits-1))-1;
    for (int num = min; num <= max; num++) {    
	int64_t result = num;
        uint64_t xsign = result >> (bits-1);
        uint64_t q0 = (mul * (xsign ^ result)) >> bits;
        result = xsign ^ (q0 >> sh_post);
	if (sdiv(num, den) != result) return false;
    }
    return true;    
}

bool s_method_2(int den, int mul, int sh_post, int bits) {
    int min = -(1 << (bits-1)), max = (1 << (bits-1))-1;
    for (int num = min; num <= max; num++) {
	int64_t result = num;
	result *= mul;
	result >>= bits;
	if (result > max || result < min) return false;
	result += (num - result+1)>>1;
	if (result > max || result < min) return false;
	result >>= sh_post;
        int64_t correct = sdiv(num, den);
	if (correct != result) return false;
    }
    return true;
}


int main(int argc, char **argv) {
    /* This program computes a table to help us do cheap integer
        division by a constant. It is based on the paper "Division by
        Invariant Integers using Multiplication" by Granlund and
        Montgomery.
    */

    printf("/** \\file \n"
           " * Tables telling us how to do integer division\n"
           " * via fixed-point multiplication for various small\n"
           " * constants. This file is automatically generated\n"
           " * by find_inverse.c\n"
           " */\n"
           "namespace Halide {\n"
           "namespace Internal {\n"
           "namespace IntegerDivision {\n\n");
    
    for (int bits = 8; bits <= 16; bits += 8) {
	int s_min = -(1 << (bits-1));
	int s_max = (1 << (bits-1))-1;
	int u_max = (1 << bits)-1;
   	
	printf("int table_u%d[][3] = {\n", bits);
	for (int den = 2; den <= 64; den++) {
	    for (int shift = 0; shift < 8; shift++) {
		if (u_method_0(den, shift, bits)) {
		    printf("    {0, 0, %d},\n", shift);
		    goto next_unsigned;
		}
	    }
	    
	    for (int shift = 0; shift < 8; shift++) {
		for (int mul = 0; mul <= u_max; mul++) {
		    if (u_method_1(den, mul, shift, bits)) {
			printf("    {1, %d, %d},\n", mul, shift);
			goto next_unsigned;
		    }
		}
	    }
	    
	    for (int shift = 0; shift < 8; shift++) {
		for (int mul = 0; mul <= u_max; mul++) {
		    if (u_method_2(den, mul, shift, bits)) {
			printf("    {2, %d, %d},\n", mul, shift);
			goto next_unsigned;
		    }
		}
	    }
	    printf("ERROR! No solution found for unsigned %d\n", den);
	  next_unsigned:;
	}
	printf("};\n");
	printf("int table_s%d[][3] = {\n", bits);
	for (int den = 2; den <= 64; den++) {

	    for (int shift = 0; shift < 8; shift++) {
		if (s_method_0(den, shift, bits)) {
		    printf("    {0, 0, %d},\n", shift);
		    goto next_signed;
		}
	    }
	    
	    for (int shift = 0; shift < 8; shift++) {
		for (int mul = 0; mul <= u_max; mul++) {
		    if (s_method_1(den, mul, shift, bits)) {
			printf("    {1, %d, %d},\n", mul, shift);
			goto next_signed;
		    }
		}
	    }
	    
	    for (int shift = 0; shift < 8; shift++) {
		for (int mul = s_min; mul <= s_max; mul++) {
		    if (s_method_2(den, mul, shift, bits)) {
			printf("    {2, %d, %d},\n", mul, shift);
			goto next_signed;
		    }
		}
	    }

          /*
	    for (int shift = 0; shift < 8; shift++) {
		for (int mul = s_min; mul <= s_max; mul++) {
		    if (s_method_0(den, mul, shift, bits)) {
			printf("    {0, %d, %d},\n", mul, shift);
			goto next_signed;
		    }
		}
	    }
	    
	    for (int shift = 0; shift < 8; shift++) {
		for (int mul = s_min; mul <= s_max; mul++) {
		    if (s_method_1(den, mul, shift, bits)) {
			printf("    {1, %d, %d},\n", mul, shift);
			goto next_signed;
		    }
		}
	    }
          */
	    printf("ERROR! No solution found for signed %d\n", den);
	  next_signed:;
	}
	printf("};\n");        
    }

    printf("}}}\n");

    return 0;
}
