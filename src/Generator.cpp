#include <cmath>
#include <fstream>
#include <set>

#include "Generator.h"
#include "Outputs.h"
#include "Simplify.h"

namespace Halide {
namespace Internal {

namespace {

// Return true iff the name is valid for Generators or Params.
// (NOTE: gcc didn't add proper std::regex support until v4.9;
// we don't yet require this, hence the hand-rolled replacement.)

bool is_alpha(char c) { return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'); }

// Note that this includes '_'
bool is_alnum(char c) { return is_alpha(c) || (c == '_') || (c >= '0' && c <= '9'); }

// Basically, a valid C identifier, except:
//
// -- initial _ is forbidden (rather than merely "reserved")
// -- two underscores in a row is also forbidden
bool is_valid_name(const std::string& n) {
    if (n.empty()) return false;
    if (!is_alpha(n[0])) return false;
    for (size_t i = 1; i < n.size(); ++i) {
        if (!is_alnum(n[i])) return false;
        if (n[i] == '_' && n[i-1] == '_') return false;
    }
    return true;
}

std::string compute_base_path(const std::string &output_dir,
                              const std::string &function_name,
                              const std::string &file_base_name) {
    std::vector<std::string> namespaces;
    std::string simple_name = extract_namespaces(function_name, namespaces);
    std::string base_path = output_dir + "/" + (file_base_name.empty() ? simple_name : file_base_name);
    return base_path;
}

std::string get_extension(const std::string& def, const GeneratorBase::EmitOptions &options) {
    auto it = options.substitutions.find(def);
    if (it != options.substitutions.end()) {
        return it->second;
    }
    return def;
}

Outputs compute_outputs(const Target &target,
                        const std::string &base_path,
                        const GeneratorBase::EmitOptions &options) {
    const bool is_windows_coff = target.os == Target::Windows &&
                                !target.has_feature(Target::MinGW);
    Outputs output_files;
    if (options.emit_o) {
        if (is_windows_coff) {
            // If it's windows, then we're emitting a COFF file
            output_files.object_name = base_path + get_extension(".obj", options);
        } else {
            // Otherwise it is an ELF or Mach-o
            output_files.object_name = base_path + get_extension(".o", options);
        }
    }
    if (options.emit_assembly) {
        output_files.assembly_name = base_path + get_extension(".s", options);
    }
    if (options.emit_bitcode) {
        // In this case, bitcode refers to the LLVM IR generated by Halide
        // and passed to LLVM.
        output_files.bitcode_name = base_path + get_extension(".bc", options);
    }
    if (options.emit_h) {
        output_files.c_header_name = base_path + get_extension(".h", options);
    }
    if (options.emit_cpp) {
        output_files.c_source_name = base_path + get_extension(".cpp", options);
    }
    if (options.emit_stmt) {
        output_files.stmt_name = base_path + get_extension(".stmt", options);
    }
    if (options.emit_stmt_html) {
        output_files.stmt_html_name = base_path + get_extension(".html", options);
    }
    if (options.emit_static_library) {
        if (is_windows_coff) {
            output_files.static_library_name = base_path + get_extension(".lib", options);
        } else {
            output_files.static_library_name = base_path + get_extension(".a", options);
        }
    }
    if (options.emit_javascript) {
        output_files.javascript_name = base_path + get_extension(".js", options);
    }
    return output_files;
}

Argument to_argument(const Internal::Parameter &param) {
    Expr def, min, max;
    if (!param.is_buffer()) {
        def = param.get_scalar_expr();
        min = param.get_min_value();
        max = param.get_max_value();
    }
    return Argument(param.name(),
        param.is_buffer() ? Argument::InputBuffer : Argument::InputScalar,
        param.type(), param.dimensions(), def, min, max);
}

std::pair<int64_t, int64_t> rational_approximation_helper(double d, int max_depth) {
    const int64_t int_part = static_cast<int64_t>(std::floor(d));
    const double float_part = d - int_part;
    if (max_depth == 0 || float_part == 0.0) {
        return {int_part, 1};
    }

    const auto r = rational_approximation_helper(1.0/float_part, max_depth - 1);
    const int64_t num = r.second;
    const int64_t den = r.first;
    if (mul_would_overflow(64, int_part, den) ||
        add_would_overflow(64, num, int_part * den)) {
        return {0, 0};
    }

    return {num + int_part * den, den};
}
    
std::pair<int64_t, int64_t> rational_approximation(double d) {
    // Special-case non-finite numbers.
    if (std::isnan(d)) return {0, 0};

    const int64_t sign = (d < 0) ? -1 : 1;
    if (!std::isfinite(d)) return {sign, 0};

    d = std::abs(d);

    // The most accurate rationals to approximate a real come from
    // truncating its continued fraction representation.  We want the
    // largest continued fraction possible, but at some point they'll
    // overflow our rational type, and because they're evaluated
    // backwards it's not easy to stop at the point which will not
    // trigger overflow. Use binary search to find the right depth.
    std::pair<int64_t, int64_t> best {0, 0};
    int lo = 0, hi = 64; 
    while (lo + 1 < hi) {
        int mid = (lo + hi)/2;
        auto next = rational_approximation_helper(d, mid);
        if (next.first == 0 && next.second == 0) {
            hi = mid;
        } else {
            lo = mid;
            best = next;
        }
    }
    
    return {best.first * sign, best.second};
}

std::vector<Type> parse_halide_type_list(const std::string &types) {
    const auto &e = get_halide_type_enum_map();
    std::vector<Type> result;
    for (auto t : split_string(types, ",")) {
        auto it = e.find(t);
        user_assert(it != e.end()) << "Type not found: " << t;
        result.push_back(it->second);
    }
    return result;
}

template<typename T>
T parse_scalar(const std::string &value) {
    std::istringstream iss(value);
    T t;
    iss >> t;
    user_assert(!iss.fail() && iss.get() == EOF) << "Unable to parse: " << value;
    return t;
}

Func make_param_func(const Parameter &p, const std::string &name) {
    internal_assert(p.is_buffer());
    std::vector<Var> args;
    std::vector<Expr> args_expr;
    for (int i = 0; i < p.dimensions(); ++i) {
        Var v = Var::implicit(i);
        args.push_back(v);
        args_expr.push_back(v);
    }
    Func f = Func(name + "_im");
    f(args) = Internal::Call::make(p, args_expr);
    return f;
}

}  // namespace

void ValueTracker::track_values(const std::string &name, const std::vector<Expr> &values) {
    std::vector<std::vector<Expr>> &history = values_history[name];
    if (history.empty()) {
        for (size_t i = 0; i < values.size(); ++i) {
            history.push_back({values[i]});
        }
        return;
    }

    internal_assert(history.size() == values.size())
        << "Expected values of size " << history.size()
        << " but saw size " << values.size()
        << " for name " << name << "\n";

    // For each item, see if we have a new unique value
    for (size_t i = 0; i < values.size(); ++i) {
        Expr oldval = history[i].back();
        Expr newval = values[i];
        if (oldval.defined() && newval.defined()) {
            if (can_prove(newval == oldval)) {
                continue;
            }
        } else if (!oldval.defined() && !newval.defined()) {
            // Expr::operator== doesn't work with undefined
            // values, but they are equal for our purposes here.
            continue;
        }
        history[i].push_back(newval);
        // If we exceed max_unique_values, fail immediately.
        // TODO: could be useful to log all the entries that
        // overflow max_unique_values before failing.
        // TODO: this could be more helpful about labeling the values
        // that have multiple setttings.
        if (history[i].size() > max_unique_values) {
            std::ostringstream o;
            o << "Saw too many unique values in ValueTracker[" + std::to_string(i) + "]; "
              << "expected a maximum of " << max_unique_values << ":\n";
            for (auto e : history[i]) {
                o << "    " << e << "\n";
            }
            user_error << o.str();
        }
    }
}

std::vector<Expr> parameter_constraints(const Parameter &p) {
    internal_assert(p.defined());
    std::vector<Expr> values;
    values.push_back(Expr(p.host_alignment()));
    if (p.is_buffer()) {
        for (int i = 0; i < p.dimensions(); ++i) {
            values.push_back(p.min_constraint(i));
            values.push_back(p.extent_constraint(i));
            values.push_back(p.stride_constraint(i));
        }
    } else {
        values.push_back(p.get_min_value());
        values.push_back(p.get_max_value());
    }
    return values;
}

class StubEmitter {
public:
    StubEmitter(std::ostream &dest, 
                const std::string &generator_name,
                const std::vector<Internal::GeneratorParamBase *>& generator_params,
                const std::vector<Internal::GeneratorInputBase *>& inputs,
                const std::vector<Internal::GeneratorOutputBase *>& outputs) 
        : stream(dest), 
          generator_name(generator_name), 
          generator_params(filter_params(generator_params, false)), 
          schedule_params(filter_params(generator_params, true)), 
          inputs(inputs), 
          outputs(outputs) {
    }

    void emit();
private:
    std::ostream &stream;
    const std::string generator_name;
    const std::vector<Internal::GeneratorParamBase *> generator_params;
    const std::vector<Internal::GeneratorParamBase *> schedule_params;
    const std::vector<Internal::GeneratorInputBase *> inputs;
    const std::vector<Internal::GeneratorOutputBase *> outputs;
    int indent_level{0};

    std::vector<Internal::GeneratorParamBase *> filter_params(const std::vector<Internal::GeneratorParamBase *> &in, 
                                                              bool is_schedule_params) {
        std::vector<Internal::GeneratorParamBase *> out;
        for (auto p : in) {
            if (p->name == "target") continue;
            if (p->is_schedule_param() != is_schedule_params) continue;
            out.push_back(p);
        }
        return out;
    }

    /** Emit spaces according to the current indentation level */
    std::string indent();

    void emit_inputs_struct();
    void emit_params_struct(bool schedule_only);
};

std::string StubEmitter::indent() {
    std::ostringstream o;
    for (int i = 0; i < indent_level; i++) {
        o << "  ";
    }
    return o.str();
}

void StubEmitter::emit_params_struct(bool is_schedule_params) {
    const auto &v = is_schedule_params ? schedule_params : generator_params;
    std::string name = is_schedule_params ? "ScheduleParams" : "GeneratorParams";
    stream << indent() << "struct " << name << " final {\n";
    indent_level++;
    if (!v.empty()) {
        for (auto p : v) {
            stream << indent() << p->get_c_type() << " " << p->name << "{ " << p->get_default_value() << " };\n";
        }
        stream << "\n";
    }

    stream << indent() << name << "() {}\n";
    stream << "\n";

    if (!v.empty()) {
        stream << indent() << name << "(\n";
        indent_level++;
        std::string comma = "";
        for (auto p : v) {
            stream << indent() << comma << p->get_c_type() << " " << p->name << "\n";
            comma = ", ";
        }
        indent_level--;
        stream << indent() << ") : \n";
        indent_level++;
        comma = "";
        for (auto p : v) {
            stream << indent() << comma << p->name << "(" << p->name << ")\n";
            comma = ", ";
        }
        indent_level--;
        stream << indent() << "{\n";
        stream << indent() << "}\n";
        stream << "\n";
    }

    stream << indent() << "inline NO_INLINE std::map<std::string, std::string> to_string_map() const {\n";
    indent_level++;
    stream << indent() << "std::map<std::string, std::string> m;\n";
    for (auto p : v) {
        if (p->is_looplevel_param()) continue;
        stream << indent() << "if (" << p->name << " != " << p->get_default_value() << ") "
                        << "m[\"" << p->name << "\"] = " << p->call_to_string(p->name) << ";\n";
    }
    stream << indent() << "return m;\n";
    indent_level--;
    stream << indent() << "}\n";

    if (is_schedule_params) {
        stream << "\n";
        stream << indent() << "inline NO_INLINE std::map<std::string, LoopLevel> to_looplevel_map() const {\n";
        indent_level++;
        stream << indent() << "std::map<std::string, LoopLevel> m;\n";
        for (auto p : v) {
            if (!p->is_looplevel_param()) continue;
            stream << indent() << "if (" << p->name << " != " << p->get_default_value() << ") "
                            << "m[\"" << p->name << "\"] = " << p->name << ";\n";
        }
        stream << indent() << "return m;\n";
        indent_level--;
        stream << indent() << "}\n";
    }

    indent_level--;
    stream << indent() << "};\n";
    stream << "\n";
}

void StubEmitter::emit_inputs_struct() {
    struct InInfo {
        std::string c_type;
        std::string name;
    };
    std::vector<InInfo> in_info;
    for (auto input : inputs) {
        std::string c_type = input->get_c_type();
        if (input->is_array()) {
            c_type = "std::vector<" + c_type + ">";
        }
        in_info.push_back({c_type, input->name()});
    }

    const std::string name = "Inputs";
    stream << indent() << "struct " << name << " final {\n";
    indent_level++;
    for (auto in : in_info) {
        stream << indent() << in.c_type << " " << in.name << ";\n";
    }
    stream << "\n";

    stream << indent() << name << "() {}\n";
    stream << "\n";

    stream << indent() << name << "(\n";
    indent_level++;
    std::string comma = "";
    for (auto in : in_info) {
        stream << indent() << comma << "const " << in.c_type << "& " << in.name << "\n";
        comma = ", ";
    }
    indent_level--;
    stream << indent() << ") : \n";
    indent_level++;
    comma = "";
    for (auto in : in_info) {
        stream << indent() << comma << in.name << "(" << in.name << ")\n";
        comma = ", ";
    }
    indent_level--;
    stream << indent() << "{\n";
    stream << indent() << "}\n";

    indent_level--;
    stream << indent() << "};\n";
    stream << "\n";
}

void StubEmitter::emit() {
    if (outputs.empty()) {
        // The generator can't support a real stub. Instead, generate an (essentially) 
        // empty .stub.h file, so that build systems like Bazel will still get the output file
        // they expected. Note that we deliberately don't emit an ifndef header guard,
        // since we can't reliably assume that the generator_name will be globally unique;
        // on the other hand, since this file is just a couple of comments, it's
        // really not an issue if it's included multiple times.
        stream << "/* MACHINE-GENERATED - DO NOT EDIT */\n";
        stream << "/* The Generator named " << generator_name << " uses ImageParam or Param, thus cannot have a Stub generated. */\n";
        return;
    }

    std::vector<std::string> namespaces = split_string(generator_name, "::");
    internal_assert(namespaces.size() >= 1);
    if (namespaces[0].empty()) {
        // We have a name like ::foo::bar::baz; omit the first empty ns.
        namespaces.erase(namespaces.begin());
        internal_assert(namespaces.size() >= 2);
    }
    const std::string class_name = namespaces.back();
    namespaces.pop_back();

    struct OutputInfo {
        std::string name;
        std::string ctype;
        std::string getter;
    };
    std::vector<OutputInfo> out_info;
    for (auto output : outputs) {
        std::string c_type = output->get_c_type();
        std::string getter;
        if (output->is_array()) getter = "get_output_vector";
        else if (c_type == "Func") getter = "get_output";
        else getter = "get_output_buffer<" + c_type + ">";
        out_info.push_back({
            output->name(),
            output->is_array() ? "std::vector<" + c_type + ">" : c_type,
            getter + "(\"" + output->name() + "\")"
        });
    }

    std::ostringstream guard;
    guard << "HALIDE_STUB";
    for (const auto &ns : namespaces) {
        guard << "_" << ns;
    }
    guard << "_" << class_name;

    stream << indent() << "#ifndef " << guard.str() << "\n";
    stream << indent() << "#define " << guard.str() << "\n";
    stream << "\n";

    stream << indent() << "/* MACHINE-GENERATED - DO NOT EDIT */\n";
    stream << "\n";

    stream << indent() << "#include <cassert>\n";
    stream << indent() << "#include <map>\n";
    stream << indent() << "#include <memory>\n";
    stream << indent() << "#include <string>\n";
    stream << indent() << "#include <utility>\n";
    stream << indent() << "#include <vector>\n";
    stream << "\n";
    stream << indent() << "#include \"Halide.h\"\n";
    stream << "\n";

    for (const auto &ns : namespaces) {
        stream << indent() << "namespace " << ns << " {\n";
    }
    stream << "\n";

    for (auto p : generator_params) {
        std::string decl = p->get_type_decls();
        if (decl.empty()) continue;
        stream << decl << "\n";
    }

    for (auto p : schedule_params) {
        std::string decl = p->get_type_decls();
        if (decl.empty()) continue;
        stream << decl << "\n";
    }

    stream << indent() << "class " << class_name << " final : public Halide::Internal::GeneratorStub {\n";
    stream << indent() << "public:\n";
    indent_level++;

    emit_inputs_struct();
    emit_params_struct(true);
    emit_params_struct(false);

    stream << indent() << class_name << "() {}\n";
    stream << "\n";

    stream << indent() << "NO_INLINE " << class_name << "(\n";
    indent_level++;
    stream << indent() << "const GeneratorContext* context,\n";
    stream << indent() << "const Inputs& inputs,\n";
    stream << indent() << "const GeneratorParams& params = GeneratorParams()\n";
    indent_level--;
    stream << indent() << ")\n";
    indent_level++;
    stream << indent() << ": GeneratorStub(context, &factory, params.to_string_map(), {\n";
    indent_level++;
    for (size_t i = 0; i < inputs.size(); ++i) {
        stream << indent() << "to_stub_input_vector(inputs." << inputs[i]->name() << ")";
        stream << ",\n";
    }
    indent_level--;
    stream << indent() << "})\n";
    for (const auto &out : out_info) {
        stream << indent() << ", " << out.name << "(" << out.getter << ")\n";
    }
    indent_level--;
    stream << indent() << "{\n";
    stream << indent() << "}\n";
    stream << "\n";

    stream << indent() << "// delegating ctor to allow GeneratorContext-ref\n";
    stream << indent() << class_name << "(\n";
    indent_level++;
    stream << indent() << "const GeneratorContext& context,\n";
    stream << indent() << "const Inputs& inputs,\n";
    stream << indent() << "const GeneratorParams& params = GeneratorParams()\n";
    indent_level--;
    stream << indent() << ")\n";
    indent_level++;
    stream << indent() << ": " << class_name << "(&context, inputs, params) {}\n";
    stream << "\n";

    if (!generator_params.empty()) {
        stream << indent() << "// templated construction method with inputs\n";
        stream << indent() << "template<\n";
        std::string comma = "";
        indent_level++;
        for (auto p : generator_params) {
            std::string type = p->get_template_type();
            std::string value = p->get_template_value();
            if (type == "float" || type == "double") {
                // floats and doubles can't be used as template value arguments;
                // it turns out to be pretty uncommon use floating point types
                // in GeneratorParams, but to avoid breaking these cases entirely, 
                // use std::ratio as an approximation for the default value.
                auto ratio = rational_approximation(std::atof(value.c_str()));
                stream << indent() << comma << "typename" << " " << p->name << " = std::ratio<" << ratio.first << ", " << ratio.second << ">\n";
            } else {
                stream << indent() << comma << type << " " << p->name << " = " << value << "\n";
            }
            comma = ", ";
        }
        indent_level--;
        stream << indent() << ">\n";
        stream << indent() << "static " << class_name << " make(const GeneratorContext* context, const Inputs& inputs) {\n";
        indent_level++;
        stream << indent() << "GeneratorParams gp(\n";
        indent_level++;
        comma = "";
        for (auto p : generator_params) {
            std::string type = p->get_template_type();
            if (type == "typename") {
                stream << indent() << comma << "Halide::type_of<" << p->name << ">()\n";
            } else if (type == "float" || type == "double") {
                stream << indent() << comma << "ratio_to_double<" << p->name << ">()\n";
            } else {
                stream << indent() << comma << p->name << "\n";
            }
            comma = ", ";
        }
        indent_level--;
        stream << indent() << ");\n";
        stream << indent() << "return " << class_name << "(context, inputs, gp);\n";
        indent_level--;
        indent_level--;
        stream << indent() << "}\n";
        stream << "\n";
    }

    stream << indent() << "// schedule method\n";
    stream << indent() << "void schedule(const ScheduleParams& params = ScheduleParams()) {\n";
    indent_level++;
    stream << indent() << "GeneratorStub::schedule(params.to_string_map(), params.to_looplevel_map());\n";
    indent_level--;
    stream << indent() << "}\n";
    stream << "\n";

    stream << indent() << "// move constructor\n";
    stream << indent() << class_name << "("<< class_name << "&& that)\n";
    indent_level++;
    stream << indent() << ": GeneratorStub(std::move(that))\n";
    for (const auto &out : out_info) {
        stream << indent() << ", " << out.name << "(std::move(that." << out.name << "))\n";
    }
    indent_level--;
    stream << indent() << "{\n";
    stream << indent() << "}\n";
    stream << "\n";

    stream << indent() << "// move assignment operator\n";
    stream << indent() << class_name << "& operator=("<< class_name << "&& that) {\n";
    indent_level++;
    stream << indent() << "GeneratorStub::operator=(std::move(that));\n";
    for (const auto &out : out_info) {
        stream << indent() << out.name << " = std::move(that." << out.name << ");\n";
    }
    stream << indent() << "return *this;\n";
    indent_level--;
    stream << indent() << "}\n";
    stream << "\n";

    stream << indent() << "// Output(s)\n";
    stream << indent() << "// TODO: identify vars used\n";
    for (const auto &out : out_info) {
        stream << indent() << out.ctype << " " << out.name << ";\n";
    }
    stream << "\n";

    stream << indent() << "~" << class_name << "() { if (has_generator()) verify(); }\n";
    stream << "\n";

    indent_level--;
    stream << indent() << "protected:\n";
    indent_level++;
    stream << indent() << "NO_INLINE void verify() {\n";
    indent_level++;
    for (const auto &out : out_info) {
        stream << indent() << "verify_same_funcs(" << out.name << ", " << out.getter << ");\n";
    }
    indent_level--;
    stream << indent() << "}\n";
    stream << "\n";

    indent_level--;
    stream << indent() << "private:\n";
    indent_level++;
    stream << indent() << "static std::unique_ptr<Halide::Internal::GeneratorBase> factory(const std::map<std::string, std::string>& params) {\n";
    indent_level++;
    stream << indent() << "return Halide::Internal::GeneratorRegistry::create(\"" << generator_name << "\", params);\n";
    indent_level--;
    stream << indent() << "};\n";
    stream << "\n";

    indent_level--;
    stream << indent() << "};\n";
    stream << "\n";

    for (int i = (int)namespaces.size() - 1; i >= 0 ; --i) {
        stream << indent() << "}  // namespace " << namespaces[i] << "\n";
    }
    stream << "\n";

    stream << indent() << "#endif  // " << guard.str() << "\n";
}

GeneratorStub::GeneratorStub(const GeneratorContext *context,
                             GeneratorFactory generator_factory,
                             const std::map<std::string, std::string> &generator_params,
                             const std::vector<std::vector<Internal::StubInput>> &inputs)
    : generator(generator_factory(generator_params)) {
    user_assert(context != nullptr) << "Context may not be null";
    internal_assert(generator->value_tracker == nullptr);
    generator->value_tracker = context->get_value_tracker();
    generator->target.set(context->get_target());
    generator->set_inputs(inputs);
    generator->call_generate();
}

void GeneratorStub::schedule(const std::map<std::string, std::string> &schedule_params,
              const std::map<std::string, LoopLevel> &schedule_params_looplevels) {
    generator->set_schedule_param_values(schedule_params, schedule_params_looplevels);
    generator->call_schedule();
}

void GeneratorStub::verify_same_funcs(const Func &a, const Func &b) {
    user_assert(a.function().get_contents().same_as(b.function().get_contents())) 
        << "Expected Func " << a.name() << " and " << b.name() << " to match.\n";
}

void GeneratorStub::verify_same_funcs(const std::vector<Func>& a, const std::vector<Func>& b) {
    user_assert(a.size() == b.size()) << "Mismatch in Function vector length.\n";
    for (size_t i = 0; i < a.size(); ++i) {
        verify_same_funcs(a[i], b[i]);
    }
}

const std::map<std::string, Type> &get_halide_type_enum_map() {
    static const std::map<std::string, Type> halide_type_enum_map{
        {"bool", Bool()},
        {"int8", Int(8)},
        {"int16", Int(16)},
        {"int32", Int(32)},
        {"uint8", UInt(8)},
        {"uint16", UInt(16)},
        {"uint32", UInt(32)},
        {"float32", Float(32)},
        {"float64", Float(64)}
    };
    return halide_type_enum_map;
}

std::string halide_type_to_c_source(const Type &t) {
    static const std::map<halide_type_code_t, std::string> m = {
        { halide_type_int, "Int" },
        { halide_type_uint, "UInt" },
        { halide_type_float, "Float" },
        { halide_type_handle, "Handle" },
    };
    std::ostringstream oss;
    oss << "Halide::" << m.at(t.code()) << "(" << t.bits() << + ")";
    return oss.str();
}

std::string halide_type_to_c_type(const Type &t) {
    auto encode = [](const Type &t) -> int { return t.code() << 16 | t.bits(); };
    static const std::map<int, std::string> m = {
        { encode(Int(8)), "int8_t" },
        { encode(Int(16)), "int16_t" },
        { encode(Int(32)), "int32_t" },
        { encode(Int(64)), "int64_t" },
        { encode(UInt(1)), "bool" },
        { encode(UInt(8)), "uint8_t" },
        { encode(UInt(16)), "uint16_t" },
        { encode(UInt(32)), "uint32_t" },
        { encode(UInt(64)), "uint64_t" },
        { encode(Float(32)), "float" },
        { encode(Float(64)), "double" },
        { encode(Handle(64)), "void*" }
    };
    return m.at(encode(t));
}

LoopLevel get_halide_undefined_looplevel() {
    static LoopLevel undefined(Func("__undefined_looplevel_func"), Var("__undefined_looplevel_var"));
    return undefined;
}

const std::map<std::string, LoopLevel> &get_halide_looplevel_enum_map() {
    static const std::map<std::string, LoopLevel> halide_looplevel_enum_map{
        {"root", LoopLevel::root()},
        {"undefined", get_halide_undefined_looplevel()},
        {"inline", LoopLevel()},
    };
    return halide_looplevel_enum_map;
}

int generate_filter_main(int argc, char **argv, std::ostream &cerr) {
    const char kUsage[] = "gengen [-g GENERATOR_NAME] [-f FUNCTION_NAME] [-o OUTPUT_DIR] [-r RUNTIME_NAME] [-e EMIT_OPTIONS] [-x EXTENSION_OPTIONS] [-n FILE_BASE_NAME] "
                          "target=target-string[,target-string...] [generator_arg=value [...]]\n\n"
                          "  -e  A comma separated list of files to emit. Accepted values are "
                          "[assembly, bitcode, cpp, h, html, o, static_library, stmt, cpp_stub, javascript]. If omitted, default value is [static_library, h].\n"
                          "  -x  A comma separated list of file extension pairs to substitute during file naming, "
                          "in the form [.old=.new[,.old2=.new2]]\n";

    std::map<std::string, std::string> flags_info = { { "-f", "" },
                                                      { "-g", "" },
                                                      { "-o", "" },
                                                      { "-e", "" },
                                                      { "-n", "" },
                                                      { "-x", "" },
                                                      { "-r", "" }};
    std::map<std::string, std::string> generator_args;

    for (int i = 1; i < argc; ++i) {
        if (argv[i][0] != '-') {
            std::vector<std::string> v = split_string(argv[i], "=");
            if (v.size() != 2 || v[0].empty() || v[1].empty()) {
                cerr << kUsage;
                return 1;
            }
            generator_args[v[0]] = v[1];
            continue;
        }
        auto it = flags_info.find(argv[i]);
        if (it != flags_info.end()) {
            if (i + 1 >= argc) {
                cerr << kUsage;
                return 1;
            }
            it->second = argv[i + 1];
            ++i;
            continue;
        }
        cerr << "Unknown flag: " << argv[i] << "\n";
        cerr << kUsage;
        return 1;
    }

    std::string runtime_name = flags_info["-r"];

    std::vector<std::string> generator_names = GeneratorRegistry::enumerate();
    if (generator_names.size() == 0 && runtime_name.empty()) {
        cerr << "No generators have been registered and not compiling a standalone runtime\n";
        cerr << kUsage;
        return 1;
    }

    std::string generator_name = flags_info["-g"];
    if (generator_name.empty() && runtime_name.empty()) {
        // If -g isn't specified, but there's only one generator registered, just use that one.
        if (generator_names.size() > 1) {
            cerr << "-g must be specified if multiple generators are registered:\n";
            for (auto name : generator_names) {
                cerr << "    " << name << "\n";
            }
            cerr << kUsage;
            return 1;
        }
        generator_name = generator_names[0];
    }
    std::string function_name = flags_info["-f"];
    if (function_name.empty()) {
        // If -f isn't specified, assume function name = generator name.
        function_name = generator_name;
    }
    std::string output_dir = flags_info["-o"];
    if (output_dir.empty()) {
        cerr << "-o must always be specified.\n";
        cerr << kUsage;
        return 1;
    }

    // It's ok to omit "target=" if we are generating *only* a cpp_stub
    const std::vector<std::string> emit_flags = split_string(flags_info["-e"], ",");
    const bool stub_only = (emit_flags.size() == 1 && emit_flags[0] == "cpp_stub");
    if (!stub_only) {
        if (generator_args.find("target") == generator_args.end()) {
            cerr << "Target missing\n";
            cerr << kUsage;
            return 1;
        }
    }

    // it's OK for file_base_name to be empty: filename will be based on function name
    std::string file_base_name = flags_info["-n"];

    GeneratorBase::EmitOptions emit_options;
    // Ensure all flags start as false.
    emit_options.emit_static_library = emit_options.emit_h = false;

    if (emit_flags.empty() || (emit_flags.size() == 1 && emit_flags[0].empty())) {
        // If omitted or empty, assume .a and .h
        emit_options.emit_static_library = emit_options.emit_h = true;
    } else {
        // If anything specified, only emit what is enumerated
        for (const std::string &opt : emit_flags) {
            if (opt == "assembly") {
                emit_options.emit_assembly = true;
            } else if (opt == "bitcode") {
                emit_options.emit_bitcode = true;
            } else if (opt == "stmt") {
                emit_options.emit_stmt = true;
            } else if (opt == "html") {
                emit_options.emit_stmt_html = true;
            } else if (opt == "cpp") {
                emit_options.emit_cpp = true;
            } else if (opt == "o") {
                emit_options.emit_o = true;
            } else if (opt == "h") {
                emit_options.emit_h = true;
            } else if (opt == "static_library") {
                emit_options.emit_static_library = true;
            } else if (opt == "cpp_stub") {
                emit_options.emit_cpp_stub = true;
            } else if (opt == "javascript") {
                emit_options.emit_javascript = true;
            } else if (!opt.empty()) {
                cerr << "Unrecognized emit option: " << opt
                     << " not one of [assembly, bitcode, cpp, h, html, o, static_library, stmt, cpp_stub, javascript], ignoring.\n";
            }
        }
    }

    auto substitution_flags = split_string(flags_info["-x"], ",");
    for (const std::string &x : substitution_flags) {
        if (x.empty()) {
            continue;
        }
        auto subst_pair = split_string(x, "=");
        if (subst_pair.size() != 2) {
            cerr << "Malformed -x option: " << x << "\n";
            cerr << kUsage;
            return 1;
        }
        emit_options.substitutions[subst_pair[0]] = subst_pair[1];
    }

    const auto target_string = generator_args["target"];
    auto target_strings = split_string(target_string, ",");
    std::vector<Target> targets;
    for (const auto &s : target_strings) {
        targets.push_back(Target(s));
    }

    if (!runtime_name.empty()) {
        if (targets.size() != 1) {
            cerr << "Only one target allowed here";
            return 1;
        }
        std::string base_path = compute_base_path(output_dir, runtime_name, "");
        Outputs output_files = compute_outputs(targets[0], base_path, emit_options);
        compile_standalone_runtime(output_files, targets[0]);
    }

    if (!generator_name.empty()) {
        std::string base_path = compute_base_path(output_dir, function_name, file_base_name);
        debug(1) << "Generator " << generator_name << " has base_path " << base_path << "\n";
        if (emit_options.emit_cpp_stub) {
            // When generating cpp_stub, we ignore all generator args passed in, and supply a fake Target.
            std::map<std::string, std::string> stub_generator_args;
            stub_generator_args["target"] = Target().to_string();
            // GeneratorRegistry::create never returns null
            auto gen = GeneratorRegistry::create(generator_name, stub_generator_args);
            auto stub_file_path = base_path + get_extension(".stub.h", emit_options);
            gen->emit_cpp_stub(stub_file_path);
        }

        // Don't bother with this if we're just emitting a cpp_stub.
        if (!stub_only) {
            Outputs output_files = compute_outputs(targets[0], base_path, emit_options);
            auto module_producer = [&generator_name, &generator_args, &cerr]
                (const std::string &name, const Target &target) -> Module {
                    auto sub_generator_args = generator_args;
                    sub_generator_args["target"] = target.to_string();
                    // Must re-create each time since each instance will have a different Target
                    // GeneratorRegistry::create never returns null
                    auto gen = GeneratorRegistry::create(generator_name, sub_generator_args);
                    return gen->build_module(name);
                };
            if (targets.size() > 1 || !emit_options.substitutions.empty()) {
                compile_multitarget(function_name, output_files, targets, module_producer, emit_options.substitutions);
            } else {
                user_assert(emit_options.substitutions.empty()) << "substitutions not supported for single-target";
                // compile_multitarget() will fail if we request anything but library and/or header,
                // so defer directly to Module::compile if there is a single target.
                module_producer(function_name, targets[0]).compile(output_files);
            }
        }
    }

    return 0;
}

GeneratorParamBase::GeneratorParamBase(const std::string &name) : name(name) {
    ObjectInstanceRegistry::register_instance(this, 0, ObjectInstanceRegistry::GeneratorParam,
                                              this, nullptr);
}

GeneratorParamBase::~GeneratorParamBase() { ObjectInstanceRegistry::unregister_instance(this); }

/* static */
GeneratorRegistry &GeneratorRegistry::get_registry() {
    static GeneratorRegistry *registry = new GeneratorRegistry;
    return *registry;
}

/* static */
void GeneratorRegistry::register_factory(const std::string &name,
                                         std::unique_ptr<GeneratorFactory> factory) {
    for (auto n : split_string(name, "::")) {
        user_assert(is_valid_name(n)) << "Invalid Generator name part: " << n;
    }
    GeneratorRegistry &registry = get_registry();
    std::lock_guard<std::mutex> lock(registry.mutex);
    internal_assert(registry.factories.find(name) == registry.factories.end())
        << "Duplicate Generator name: " << name;
    registry.factories[name] = std::move(factory);
}

/* static */
void GeneratorRegistry::unregister_factory(const std::string &name) {
    GeneratorRegistry &registry = get_registry();
    std::lock_guard<std::mutex> lock(registry.mutex);
    internal_assert(registry.factories.find(name) != registry.factories.end())
        << "Generator not found: " << name;
    registry.factories.erase(name);
}

/* static */
std::unique_ptr<GeneratorBase> GeneratorRegistry::create(const std::string &name,
                                                         const std::map<std::string, std::string> &params) {
    GeneratorRegistry &registry = get_registry();
    std::lock_guard<std::mutex> lock(registry.mutex);
    auto it = registry.factories.find(name);
    if (it == registry.factories.end()) {
        std::ostringstream o;
        o << "Generator not found: " << name << "\n";
        o << "Did you mean:\n";
        for (const auto &n : registry.factories) {
            o << "    " << n.first << "\n";
        }
        user_error << o.str();
    }
    std::unique_ptr<GeneratorBase> g = it->second->create(params);
    internal_assert(g != nullptr);
    return g;
}

/* static */
std::vector<std::string> GeneratorRegistry::enumerate() {
    GeneratorRegistry &registry = get_registry();
    std::lock_guard<std::mutex> lock(registry.mutex);
    std::vector<std::string> result;
    for (const auto& i : registry.factories) {
        result.push_back(i.first);
    }
    return result;
}

GeneratorBase::GeneratorBase(size_t size, const void *introspection_helper) 
    : size(size) {
    ObjectInstanceRegistry::register_instance(this, size, ObjectInstanceRegistry::Generator, this, introspection_helper);
}

GeneratorBase::~GeneratorBase() { 
    ObjectInstanceRegistry::unregister_instance(this); 
}

void GeneratorBase::build_params(bool force) {
    if (force) {
        params_built = false;
        filter_inputs.clear();
        filter_outputs.clear();
        filter_params.clear();
        generator_params.clear();
    }
    if (!params_built) {
        std::set<std::string> names;
        std::vector<void *> vf = ObjectInstanceRegistry::instances_in_range(
            this, size, ObjectInstanceRegistry::FilterParam);
        for (auto v : vf) {
            auto param = static_cast<Parameter *>(v);
            internal_assert(param != nullptr);
            user_assert(param->is_explicit_name()) << "Params in Generators must have explicit names: " << param->name();
            user_assert(is_valid_name(param->name())) << "Invalid Param name: " << param->name();
            user_assert(!names.count(param->name())) << "Duplicate Param name: " << param->name();
            names.insert(param->name());
            filter_params.push_back(param);
        }

        std::vector<void *> vi = ObjectInstanceRegistry::instances_in_range(
            this, size, ObjectInstanceRegistry::GeneratorInput);
        for (auto v : vi) {
            auto input = static_cast<Internal::GeneratorInputBase *>(v);
            internal_assert(input != nullptr);
            user_assert(is_valid_name(input->name())) << "Invalid Input name: (" << input->name() << ")\n";
            user_assert(!names.count(input->name())) << "Duplicate Input name: " << input->name();
            names.insert(input->name());
            filter_inputs.push_back(input);
        }

        std::vector<void *> vo = ObjectInstanceRegistry::instances_in_range(
            this, size, ObjectInstanceRegistry::GeneratorOutput);
        for (auto v : vo) {
            auto output = static_cast<Internal::GeneratorOutputBase *>(v);
            internal_assert(output != nullptr);
            user_assert(is_valid_name(output->name())) << "Invalid Output name: (" << output->name() << ")\n";
            user_assert(!names.count(output->name())) << "Duplicate Output name: " << output->name();
            names.insert(output->name());
            filter_outputs.push_back(output);
        }

        if (filter_params.size() > 0 && filter_inputs.size() > 0) {
            user_error << "Input<> may not be used with Param<> or ImageParam in Generators.\n";
        }

        if (filter_params.size() > 0 && filter_outputs.size() > 0) {
            user_error << "Output<> may not be used with Param<> or ImageParam in Generators.\n";
        }

        if (filter_inputs.size() > 0 && filter_outputs.size() == 0) {
            // This doesn't catch *every* possibility (since a Generator can have zero Inputs).
            user_error << "Output<> must be used with Input<> in Generators.\n";
        }

        std::vector<void *> vg = ObjectInstanceRegistry::instances_in_range(
            this, size, ObjectInstanceRegistry::GeneratorParam);
        for (auto v : vg) {
            auto param = static_cast<GeneratorParamBase *>(v);
            internal_assert(param != nullptr);
            user_assert(is_valid_name(param->name)) << "Invalid GeneratorParam name: " << param->name;
            user_assert(!names.count(param->name)) << "Duplicate GeneratorParam name: " << param->name;
            names.insert(param->name);
            generator_params.push_back(param);
        }
        params_built = true;
    }
}

Func GeneratorBase::get_first_output() {
    build_params();
    return get_output(filter_outputs[0]->name());
}

Func GeneratorBase::get_output(const std::string &n) {
    user_assert(generate_called) << "Must call generate() before accessing Generator outputs."; 
    // There usually are very few outputs, so a linear search is fine
    build_params();
    for (auto output : filter_outputs) {
        if (output->name() == n) {
            user_assert(output->array_size_defined()) << "Output " << n << " has no ArraySize defined.\n";
            user_assert(!output->is_array() && output->funcs().size() == 1) << "Output " << n << " must be accessed via get_output_vector()\n";
            Func f = output->funcs().at(0);
            user_assert(f.defined()) << "Output " << n << " was not defined.\n";
            return f;
        }
    }
    internal_error << "Output " << n << " not found.\n";
    return Func();
}

std::vector<Func> GeneratorBase::get_output_vector(const std::string &n) {
    user_assert(generate_called) << "Must call generate() before accessing Generator outputs."; 
    // There usually are very few outputs, so a linear search is fine
    build_params();
    for (auto output : filter_outputs) {
        if (output->name() == n) {
            user_assert(output->array_size_defined()) << "Output " << n << " has no ArraySize defined.\n";
            for (const auto &f : output->funcs()) {
                user_assert(f.defined()) << "Output " << n << " was not fully defined.\n";
            }
            return output->funcs();
        }
    }
    internal_error << "Output " << n << " not found.\n";
    return {};
}

void GeneratorBase::set_generator_param_values(const std::map<std::string, std::string> &params) {
    user_assert(!generator_params_set) << "set_generator_param_values() must be called at most once per Generator instance.\n";
    build_params();
    std::map<std::string, GeneratorParamBase *> generator_param_names;
    for (auto p : generator_params) {
        generator_param_names[p->name] = p;
    }
    std::map<std::string, GIOBase *> type_names, dim_names, array_size_names;
    for (auto i : filter_inputs) {
        if (!i->allow_synthetic_generator_params()) {
            continue;
        }
        if (i->kind() != IOKind::Scalar) {
            type_names[i->name() + ".type"] = i;
            dim_names[i->name() + ".dim"] = i;
        }
        if (i->is_array()) {
            array_size_names[i->name() + ".size"] = i;    
        }
    }
    for (auto o : filter_outputs) {
        if (!o->allow_synthetic_generator_params()) {
            continue;
        }
        if (o->kind() != IOKind::Scalar) {
            type_names[o->name() + ".type"] = o;
            dim_names[o->name() + ".dim"] = o;
        }
        if (o->is_array()) {
            array_size_names[o->name() + ".size"] = o;    
        }
    }
    for (auto key_value : params) {
        const std::string &key = key_value.first;
        const std::string &value = key_value.second;
        {
            auto p = generator_param_names.find(key);
            if (p != generator_param_names.end()) {
                p->second->set_from_string(value);
                continue;
            }
        }
        {
            auto p = type_names.find(key);
            if (p != type_names.end()) {
                p->second->types_ = parse_halide_type_list(value);
                continue;
            }
        }
        {
            auto p = dim_names.find(key);
            if (p != dim_names.end()) {
                p->second->dimensions_ = parse_scalar<int>(value);
                continue;
            }
        }
        {
            auto p = array_size_names.find(key);
            if (p != array_size_names.end()) {
                p->second->array_size_ = parse_scalar<size_t>(value);
                continue;
            }
        }
        user_error << "Generator " << generator_name << " has no GeneratorParam named: " << key << "\n";
    }
    generator_params_set = true;
}

void GeneratorBase::set_schedule_param_values(const std::map<std::string, std::string> &params, 
                                              const std::map<std::string, LoopLevel> &looplevel_params) {
    user_assert(!schedule_params_set) << "set_schedule_param_values() must be called at most once per Generator instance.\n";
    build_params();
    std::map<std::string, GeneratorParamBase *> m;
    for (auto param : generator_params) {
        m[param->name] = param;
    }
    for (auto key_value : params) {
        const std::string &key = key_value.first;
        const std::string &value = key_value.second;
        auto p = m.find(key);
        user_assert(p != m.end()) << "Generator has no GeneratorParam named: " << key << "\n";
        // It's not OK to set non-schedule params here.
        user_assert(p->second->is_schedule_param()) << "GeneratorParam cannot be specified for: " << key;
        p->second->set_from_string(value);
    }
    for (auto key_value : looplevel_params) {
        const std::string &key = key_value.first;
        const LoopLevel &value = key_value.second;
        auto p = m.find(key);
        user_assert(p != m.end()) << "Generator has no GeneratorParam named: " << key << "\n";
        user_assert(p->second->is_schedule_param()) << "LoopLevel param cannot be specified for: " << key;
        static_cast<GeneratorParam<LoopLevel> *>(p->second)->set(value);
    }
    schedule_params_set = true;
}

void GeneratorBase::set_inputs(const std::vector<std::vector<StubInput>> &inputs) {
    internal_assert(!inputs_set) << "set_inputs() must be called at most once per Generator instance.\n";
    build_params();
    user_assert(inputs.size() == filter_inputs.size()) 
            << "Expected exactly " << filter_inputs.size() 
            << " inputs but got " << inputs.size() << "\n";
    for (size_t i = 0; i < filter_inputs.size(); ++i) {
        filter_inputs[i]->set_inputs(inputs[i]);
    }
    inputs_set = true;
}

void GeneratorBase::track_parameter_values(bool include_outputs) {
    if (value_tracker == nullptr) {
        value_tracker = std::make_shared<ValueTracker>();
    }
    for (auto input : filter_inputs) {
        if (input->kind() == IOKind::Buffer) {
            Parameter p = input->parameter();
            // This must use p.name(), *not* input->name()
            value_tracker->track_values(p.name(), parameter_constraints(p));
        }
    }
    if (include_outputs) {
        for (auto output : filter_outputs) {
            if (output->kind() == IOKind::Buffer) {
                Parameter p = output->parameter();
                // This must use p.name(), *not* output->name()
                value_tracker->track_values(p.name(), parameter_constraints(p));
            }
        }
    }
}

void GeneratorBase::pre_generate() {
    user_assert(!generate_called) << "You may not call the generate() method more than once per instance.";
    user_assert(filter_params.size() == 0) << "May not use generate() method with Param<> or ImageParam.";
    user_assert(filter_outputs.size() > 0) << "Must use Output<> with generate() method.";
    if (!inputs_set) {
        for (auto input : filter_inputs) {
            input->init_internals();
        }
        inputs_set = true;
    }
    for (auto output : filter_outputs) {
        output->init_internals();
    }
    track_parameter_values(false);
}

void GeneratorBase::post_generate() {
    generate_called = true;
    track_parameter_values(true);
}

void GeneratorBase::pre_schedule() {
    user_assert(generate_called) << "You must call the generate() method before calling the schedule() method.";
    user_assert(!schedule_called) << "You may not call the schedule() method more than once per instance.";
    track_parameter_values(true);
}

void GeneratorBase::post_schedule() {
    schedule_called = true;
    track_parameter_values(true);
}

void GeneratorBase::pre_build() {
    user_assert(filter_inputs.size() == 0) << "May not use build() method with Input<>.";
    user_assert(filter_outputs.size() == 0) << "May not use build() method with Output<>.";
    track_parameter_values(false);
}

void GeneratorBase::post_build() {
    track_parameter_values(true);
}

Pipeline GeneratorBase::produce_pipeline() {
    user_assert(filter_outputs.size() > 0) << "Must use produce_pipeline<> with Output<>.";
    std::vector<Func> funcs;
    for (auto output : filter_outputs) {
        for (const auto &f : output->funcs()) {
            user_assert(f.defined()) << "Output \"" << f.name() << "\" was not defined.\n";
            if (output->dimensions_defined()) {
                user_assert(f.dimensions() == output->dimensions()) << "Output \"" << f.name() 
                    << "\" requires dimensions=" << output->dimensions() 
                    << " but was defined as dimensions=" << f.dimensions() << ".\n";
            }
            if (output->types_defined()) {
                user_assert((int)f.outputs() == (int)output->types().size()) << "Output \"" << f.name() 
                        << "\" requires a Tuple of size " << output->types().size() 
                        << " but was defined as Tuple of size " << f.outputs() << ".\n";
                for (size_t i = 0; i < f.output_types().size(); ++i) {
                    Type expected = output->types().at(i);
                    Type actual = f.output_types()[i];
                    user_assert(expected == actual) << "Output \"" << f.name() 
                        << "\" requires type " << expected 
                        << " but was defined as type " << actual << ".\n";
                }
            }
            funcs.push_back(f);
        }
    }
    return Pipeline(funcs);
}

Module GeneratorBase::build_module(const std::string &function_name,
                                   const LoweredFunc::LinkageType linkage_type) {
    build_params();
    Pipeline pipeline = build_pipeline();
    // Building the pipeline may mutate the Params/ImageParams (but not Inputs).
    if (filter_params.size() > 0) {
        build_params(true);
    }

    std::vector<Argument> filter_arguments;
    for (auto param : filter_params) {
        filter_arguments.push_back(to_argument(*param));
    }
    for (auto input : filter_inputs) {
        for (const auto &p : input->parameters_) {
            filter_arguments.push_back(to_argument(p));
        }
    }
    return pipeline.compile_to_module(filter_arguments, function_name, target, linkage_type);
}

void GeneratorBase::emit_cpp_stub(const std::string &stub_file_path) {
    user_assert(!generator_name.empty()) << "Generator has no name.\n";
    build_params();
    std::ofstream file(stub_file_path);
    StubEmitter emit(file, generator_name, generator_params, filter_inputs, filter_outputs);
    emit.emit();
}

GIOBase::GIOBase(size_t array_size, 
                 const std::string &name, 
                 IOKind kind,             
                 const std::vector<Type> &types,
                 int dimensions) 
    : array_size_(array_size), name_(name), kind_(kind), types_(types), dimensions_(dimensions) {
}

GIOBase::~GIOBase() { 
    // nothing
}

bool GIOBase::array_size_defined() const {
    return array_size_ != -1;  
}

size_t GIOBase::array_size() const { 
    internal_assert(array_size_defined()) << "ArraySize is unspecified for " << name() 
        << "; you need to explicit set it via the resize() method or by setting " 
        << name() << ".size = value in your build rules.";
    return (size_t) array_size_; 
}

bool GIOBase::is_array() const { 
    internal_error << "Unimplemented"; return false; 
}

const std::string &GIOBase::name() const { 
    return name_; 
}

IOKind GIOBase::kind() const { 
    return kind_; 
}

bool GIOBase::types_defined() const {
    return !types_.empty();  
}

const std::vector<Type> &GIOBase::types() const { 
    internal_assert(types_defined()) << "Type is unspecified for " << name() << "\n";
    return types_; 
}

Type GIOBase::type() const { 
    internal_assert(types_.size() == 1) << "Expected types_.size() == 1, saw " << types_.size() << " for " << name() << "\n";
    return types_.at(0); 
}

bool GIOBase::dimensions_defined() const {
    return dimensions_ != -1;  
}

int GIOBase::dimensions() const { 
    internal_assert(dimensions_defined()) << "Dimensions unspecified for " << name() << "\n";
    return dimensions_; 
}

const std::vector<Func> &GIOBase::funcs() const {
    internal_assert(funcs_.size() == array_size() && exprs_.empty());
    return funcs_;
}

const std::vector<Expr> &GIOBase::exprs() const {
    internal_assert(exprs_.size() == array_size() && funcs_.empty());
    return exprs_;
}

void GIOBase::verify_internals() const {
    user_assert(dimensions_ >= 0) << "Generator Input/Output Dimensions must have positive values";

    if (kind() != IOKind::Scalar) {
        for (const Func &f : funcs()) {
            user_assert(f.defined()) << "Input/Output " << name() << " is not defined.\n";
            user_assert(f.dimensions() == dimensions()) 
                << "Expected dimensions " << dimensions() 
                << " but got " << f.dimensions()
                << " for " << name() << "\n";
            user_assert(f.outputs() == 1)
                << "Expected outputs() == " << 1 
                << " but got " << f.outputs()
                << " for " << name() << "\n";
            user_assert(f.output_types().size() == 1)
                << "Expected output_types().size() == " << 1 
                << " but got " << f.outputs()
                << " for " << name() << "\n";
            user_assert(f.output_types()[0] == type()) 
                << "Expected type " << type() 
                << " but got " << f.output_types()[0] 
                << " for " << name() << "\n";
        }
    } else {
        for (const Expr &e : exprs()) {
            user_assert(e.defined()) << "Input/Ouput " << name() << " is not defined.\n";
            user_assert(e.type() == type())
                << "Expected type " << type() 
                << " but got " << e.type()
                << " for " << name() << "\n";
        }
    }
}

std::string GIOBase::array_name(size_t i) const {
    std::string n = name();
    if (is_array()) {
        n += "_" + std::to_string(i);
    }
    return n;
}

// If our type(s) are defined, ensure it matches the ones passed in, asserting if not.
// If our type(s) are not defined, just set to the ones passed in.
// (Ditto for dims.)
void GIOBase::check_matching_type_and_dim(const std::vector<Type> &t, int d) {
    if (types_defined()) {
        user_assert(types().size() == t.size()) << "Type mismatch for " << name() << ": expected " << types().size() << " types but saw " << t.size();
        for (size_t i = 0; i < t.size(); ++i) {
            user_assert(types().at(i) == t.at(i)) << "Type mismatch for " << name() << ": expected " << types().at(i) << " saw " << t.at(i);
        }
    } else {
        types_ = t;
    }
    internal_assert(d >= 0);
    if (dimensions_defined()) {
        user_assert(dimensions() == d) << "Dimensions mismatch for " << name() << ": expected " << dimensions() << " saw " << d;
    } else {
        dimensions_ = d;
    }
}

void GIOBase::check_matching_array_size(size_t size) {
    if (array_size_defined()) {
        user_assert(array_size() == size) << "ArraySize mismatch for " << name() << ": expected " << array_size() << " saw " << size;
    } else {
        array_size_ = size;
    }
}

GeneratorInputBase::GeneratorInputBase(size_t array_size,
                                       const std::string &name, 
                                       IOKind kind, 
                                       const std::vector<Type> &t, 
                                       int d) 
    : GIOBase(array_size, name, kind, t, d) {
    ObjectInstanceRegistry::register_instance(this, 0, ObjectInstanceRegistry::GeneratorInput, this, nullptr);
}

GeneratorInputBase::~GeneratorInputBase() { 
    ObjectInstanceRegistry::unregister_instance(this); 
}

void GeneratorInputBase::set_def_min_max() {
    // nothing
}

void GeneratorInputBase::init_parameters() {
    parameters_.clear();
    for (size_t i = 0; i < array_size(); ++i) {
        parameters_.emplace_back(type(), kind() != IOKind::Scalar, dimensions(), array_name(i), true, false);
    }
    set_def_min_max();
}

void GeneratorInputBase::verify_internals() const {
    GIOBase::verify_internals();

    const size_t expected = (kind() != IOKind::Scalar) ? funcs().size() : exprs().size();
    user_assert(parameters_.size() == expected) << "Expected parameters_.size() == " 
        << expected << ", saw " << parameters_.size() << " for " << name() << "\n";
}

void GeneratorInputBase::init_internals() {
    user_assert(array_size_defined()) << "ArraySize is not defined for Input " << name() << "; you may need to specify a GeneratorParam.\n";
    user_assert(types_defined()) << "Type is not defined for Input " << name() << "; you may need to specify a GeneratorParam.\n";
    user_assert(dimensions_defined()) << "Dimensions is not defined for Input " << name() << "; you may need to specify a GeneratorParam.\n";

    init_parameters();

    exprs_.clear();
    funcs_.clear();
    for (size_t i = 0; i < array_size(); ++i) {
        if (kind() != IOKind::Scalar) {
            internal_assert(dimensions() == parameters_[i].dimensions());
            funcs_.push_back(make_param_func(parameters_[i], array_name(i) + "_im"));
        } else {
            Expr e = Internal::Variable::make(type(), array_name(i), parameters_[i]);
            exprs_.push_back(e);
        }
    }
    
    verify_internals();
}

void GeneratorInputBase::set_inputs(const std::vector<StubInput> &inputs) {
    parameters_.clear();
    exprs_.clear();
    funcs_.clear();
    check_matching_array_size(inputs.size());
    for (size_t i = 0; i < inputs.size(); ++i) {
        const StubInput &in = inputs.at(i);
        user_assert(in.kind() == kind()) << "An input for " << name() << " is not of the expected kind.\n";
        if (kind() == IOKind::Function) {
            auto f = in.func();
            check_matching_type_and_dim(f.output_types(), f.dimensions());
            funcs_.push_back(f);
            parameters_.emplace_back(f.output_types().at(0), true, f.dimensions(), array_name(i), true, false);
        } else if (kind() == IOKind::Buffer) {
            auto p = in.parameter();
            check_matching_type_and_dim({p.type()}, p.dimensions());
            auto b = p.get_buffer();
            if (b.defined()) {
                // If the Parameter has an explicit BufferPtr set, bind directly to
                // it (this happens in JIT mode and also with statically-compiled 
                // Buffers)
                Func f(name() + "_im");
                f(_) = b(_);
                funcs_.push_back(f);
            } else {
                funcs_.push_back(make_param_func(p, name()));
            }
            parameters_.push_back(p);
        } else {
            auto e = in.expr();
            check_matching_type_and_dim({e.type()}, 0);
            exprs_.push_back(e);
            parameters_.emplace_back(e.type(), false, 0, array_name(i), true, false);
        }
    }
    
    set_def_min_max();

    verify_internals();
}

GeneratorOutputBase::GeneratorOutputBase(size_t array_size, const std::string &name, IOKind kind, const std::vector<Type> &t, int d) 
    : GIOBase(array_size, name, kind, t, d) {
    internal_assert(kind != IOKind::Scalar);
    ObjectInstanceRegistry::register_instance(this, 0, ObjectInstanceRegistry::GeneratorOutput,
                                              this, nullptr);
}

GeneratorOutputBase::~GeneratorOutputBase() { 
    ObjectInstanceRegistry::unregister_instance(this); 
}

void GeneratorOutputBase::init_internals() {
    // user_assert(array_size_defined()) << "ArraySize is not defined for Output " << name() << "; you may need to specify a GeneratorParam.\n";
    // user_assert(types_defined()) << "Type is not defined for Output " << name() << "; you may need to specify a GeneratorParam.\n";
    // user_assert(dimensions_defined()) << "Dimensions is not defined for Output " << name() << "; you may need to specify a GeneratorParam.\n";

    exprs_.clear();
    funcs_.clear();
    if (array_size_defined()) {
        for (size_t i = 0; i < array_size(); ++i) {
            funcs_.push_back(Func(array_name(i)));
        }
    }
}

void GeneratorOutputBase::resize(size_t size) {
    internal_assert(is_array());
    internal_assert(!array_size_defined()) << "You may only call " << name() 
        << ".resize() when then size is undefined\n";
    array_size_ = (int) size;
    init_internals();
}

void StubOutputBufferBase::check_scheduled(const char* m) const { 
    user_assert(generator->schedule_called) << "Must call schedule() before calling " << m << "()"; 
}

Target StubOutputBufferBase::get_target() const { 
    return generator->get_target();
}

void generator_test() {
    GeneratorParam<int> gp("gp", 1);

    // Verify that RDom parameter-pack variants can convert GeneratorParam to Expr
    RDom rdom(0, gp, 0, gp);

    // Verify that Func parameter-pack variants can convert GeneratorParam to Expr
    Var x, y;
    Func f, g;
    f(x, y) = x + y;
    g(x, y) = f(gp, gp);                            // check Func::operator() overloads
    g(rdom.x, rdom.y) += f(rdom.x, rdom.y);
    g.update(0).reorder(rdom.y, rdom.x);            // check Func::reorder() overloads for RDom::operator RVar()

    // Verify that print() parameter-pack variants can convert GeneratorParam to Expr
    print(f(0, 0), g(1, 1), gp);
    print_when(true, f(0, 0), g(1, 1), gp);

    // Verify that Tuple parameter-pack variants can convert GeneratorParam to Expr
    Tuple t(gp, gp, gp);

    // Test rational_approximation
    auto check_ratio = [](double d, std::pair<int64_t, int64_t> expected) {
        auto actual = rational_approximation(d);
        internal_assert(actual == expected) 
            << "rational_approximation(" << d << ") failed:"
            << " expected " << expected.first << "/" << expected.second
            << " actual " << actual.first << "/" << actual.second << "\n";
    };

    // deliberately use fractional values that are exactly representable so that
    // we minimize testing variation across compilers
    const double kFrac1 = 1234.125;
    const double kFrac2 = 123412341234.125;
    const double kFrac3 = 1.0/65536.0;

    check_ratio(0.0,        {0, 1});
    check_ratio(1.0,        {1, 1});
    check_ratio(2.0,        {2, 1});
    check_ratio(kFrac1,     {9873, 8});
    check_ratio(kFrac2,     {987298729873, 8});
    check_ratio(kFrac3,     {1, 65536});

    check_ratio(-0.0,       {0, 1});
    check_ratio(-1.0,       {-1, 1});
    check_ratio(-2.0,       {-2, 1});
    check_ratio(-kFrac1,    {-9873, 8});
    check_ratio(-kFrac2,    {-987298729873, 8});
    check_ratio(-kFrac3,    {-1, 65536});

    check_ratio(NAN, {0, 0});
    check_ratio(INFINITY, {1, 0});
    check_ratio(-INFINITY, {-1, 0});
}

}  // namespace Internal
}  // namespace Halide
