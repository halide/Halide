#if __cplusplus > 199711L

#include "Halide.h"

using std::unique_ptr;
using namespace Halide;

enum class SomeEnum { Foo, Bar };

class ExampleGen : public Generator<ExampleGen> {
public:
    // GeneratorParams, ImageParams, and Params are (by convention)
    // always public and always declared at the top of the Generator,
    // in the order
    //    GeneratorParam(s)
    //    ImageParam(s)
    //    Param(s)
    //
    // Note that the ImageParams/Params will appear in the C function
    // call in the order they are declared. (GeneratorParams are always
    // referenced by name, not position, so their order is irrelevant.)
    //
    // All Param variants declared as Generator members must have explicit
    // names, and all such names must match the regex [A-Za-z_][A-Za-z_0-9]*
    // (i.e., essentially a C/C++ variable name). (Note that autogenerated
    // Param names do not match this pattern, and thus will be rejected.)
    // By convention, the name should match the member-variable name.

    // GeneratorParams can be float or ints: {default} or {default, min, max}
    // (Note that if you want to specify min and max, you must specify both.)
    GeneratorParam<float> compiletime_factor{ "compiletime_factor", 1, 0, 100 };
    GeneratorParam<int> channels{ "channels", 3 };
    // ...or enums: {default, name->value map}
    GeneratorParam<SomeEnum> enummy{ "enummy",
                                     SomeEnum::Foo,
                                     { { "foo", SomeEnum::Foo }, { "bar", SomeEnum::Bar } } };
    // ...or bools: {default}
    GeneratorParam<bool> flag{ "flag", true };

    // Param (and ImageParam) are arguments passed to the filter when
    // it is executed (as opposed to the generator during compilation).
    // When jitting, there is effectively little difference between the
    // two (at least for scalar values). Note that we set a default value of
    // 1.0 so that invocations that don't set it explicitly use a predictable value.
    Param<float> runtime_factor{ 1.0, "runtime_factor" };

    Func build() override {
        Var x, y, c;
        Func f, g, h;

        f(x, y) = max(x, y);
        g(x, y, c) = cast<int32_t>(f(x, y) * c * compiletime_factor * runtime_factor);

        g.bound(c, 0, channels).reorder(c, x, y).unroll(c);

        return g;
    }
};

// If you're only using a Generator with the JIT, you don't need to register it;
// however, registering it is needed for working seamlessly with the ahead-of-time
// compilation tools, so it's generally recommended to always register it.
// (As with Params, the name is constrained to C-like patterns.)
RegisterGenerator<ExampleGen> register_jit_example("jit_example");

void verify(const Image<int> &img, float compiletime_factor, float runtime_factor, int channels) {
    for (int i = 0; i < 32; i++) {
        for (int j = 0; j < 32; j++) {
            for (int c = 0; c < channels; c++) {
                if (img(i, j, c) !=
                    (int32_t)(compiletime_factor * runtime_factor * c * (i > j ? i : j))) {
                    printf("img[%d, %d, %d] = %d\n", i, j, c, img(i, j, c));
                    exit(-1);
                }
            }
        }
    }
}

int main(int argc, char **argv) {
    {
        // Create a Generator and set its GeneratorParams by a map
        // of key-value pairs. Values are looked up by name, order doesn't matter.
        // GeneratorParams not set here retain their existing values. (Note that
        // all Generators have a "target" GeneratorParam, which is just
        // a Halide::Target set using the normal syntax.)
        ExampleGen gen;
        gen.set_generator_param_values({ { "compiletime_factor", "2.3" },
                                         { "channels", "3" },
                                         { "target", "host" },
                                         { "enummy", "foo" },
                                         { "flag", "false" } });
        Image<int> img = gen.build().realize(32, 32, 3, gen.get_target());
        verify(img, 2.3, 1, 3);
    }
    {
        // You can also set the GeneratorParams after creation by setting the
        // member values directly, of course.
        ExampleGen gen;
        gen.compiletime_factor.set(2.9);
        Image<int> img = gen.build().realize(32, 32, 3);
        verify(img, 2.9, 1, 3);

        // You can change the GeneratorParams between each call to build().
        gen.compiletime_factor.set(0.1);
        gen.channels.set(4);
        Image<int> img2 = gen.build().realize(32, 32, 4);
        verify(img2, 0.1, 1, 4);

        // Setting non-existent GeneratorParams will fail with a user_assert.
        // gen->set_generator_param_values({{"unknown_name", "0.1"}});

        // Setting GeneratorParams to values that can't be properly parsed
        // into the correct type will fail with a user_assert.
        // gen->set_generator_param_values({{"compiletime_factor", "this is not a number"}});
        // gen->set_generator_param_values({{"channels", "neither is this"}});
        // gen->set_generator_param_values({{"enummy", "not_in_the_enum_map"}});
        // gen->set_generator_param_values({{"flag", "maybe"}});
        // gen->set_generator_param_values({{"target", "6502-8"}});
    }
    {
        // If you're fine with the default values of all GeneratorParams,
        // you can just use a temporary:
        Image<int> img = ExampleGen().build().realize(32, 32, 3);
        verify(img, 1, 1, 3);
    }
    {
        // Want to set both GeneratorParams and FilterParams
        // (aka Runtime Params aka plain-old-params)? The currently-recommended
        // approach is to set all before calling build() or realize().
        // (Better approaches should be possible in the future.)
        ExampleGen gen;
        gen.compiletime_factor.set(1.234f);
        gen.runtime_factor.set(3.456f);
        Image<int> img = gen.build().realize(32, 32, 3);
        verify(img, 1.234f, 3.456f, 3);
    }

    printf("Success!\n");
    return 0;
}

#else

#include <stdio.h>

int main(int argc, char **argv) {
    printf("This test requires C++11\n");
    return 0;
}

#endif
